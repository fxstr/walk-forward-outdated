{"version":3,"sources":["../../src/data-series/TransformableDataSeries.mjs"],"names":["DataSeries","logger","convertObjectToMap","debug","TransformableDataSeries","add","data","resetExecutedTransformers","prototype","call","Map","executeAllTransformers","set","executedTransformers","wasTransformerExecuted","transformer","indexOf","allPropertiesAvailable","properties","Array","isArray","Error","headRow","head","every","property","has","map","get","nextExecution","getNextTransformerToExecute","transformerResult","next","push","addTransformedData","transformers","propertiesForTransformer","returnValue","constructor","name","result","rowData","newCols","key","value","keys","undefined","resultKey","columns","addTransformer"],"mappings":"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","sourcesContent":["import DataSeries from './DataSeries';\nimport logger from '../logger/logger';\nimport convertObjectToMap from './convertObjectToMap';\nconst { debug } = logger('WalkForward:TransformableDataSeries');\n\n/**\n* Extends DataSeries with transformers.\n*/\nexport default class TransformableDataSeries extends DataSeries {\n\n\t/** \n\t* @private \n\t*/\n\ttransformers = [];\n\n\t/**\n\t* Holds all transformers that were executed for the current row (see this.head()), needed to\n\t* make sure we don't execute a transformer multiple times for a given row.\n\t* @private\n\t*/\n\texecutedTransformers = [];\n\n\t/**\n\t* If a transformer's next() method does not return an object, convert it to an object and use\n\t* this variable's value as the key.\n\t* @private\n\t*/\n\tdefaultReturnValuePropertyName = 'value';\n\n\n\t/**\n\t* Adds one or multiple data values for a given key. Only one row (key) may be passed. *After*\n\t* the row is added, registered transformers are executed.\n\t* @param {object} data\n\t* @returns {Promise}\n\t*/\n\tasync add(data) {\n\n\t\t// Re-start transform process\n\t\tthis.resetExecutedTransformers();\n\n\t\t// If there are transformers with *no* dependencies, execute them before any data is added\n\t\t// (this is a question of definition, could also be done after add is executed)\n\t\t// To do so, we \n\t\t// - first create an empty entry (with an empty Map())\n\t\t// - then execute the transformers without dependencies\n\t\t// - then add the data (through set)\n\n\t\t// Super is not supported on async functions in babel, see \n\t\t// https://github.com/babel/babel/issues/3930\n\t\tDataSeries.prototype.add.call(this, new Map());\n\t\tawait this.executeAllTransformers();\n\n\t\t// set executes all transformers – no need to do it here.\n\t\tawait this.set(data);\n\n\t}\n\n\n\t/**\n\t* Resets this.executedTransformers; needs to be done when a new row is added.\n\t* @private\n\t*/\n\tresetExecutedTransformers() {\n\t\tthis.executedTransformers = [];\n\t}\n\n\n\t/**\n\t* Adds data (columns) to the head row. Is needed for external scripts to modify the\n\t* DataSeries and to add results of transformations. Then executes registered transformers.\n\t* @param {object} data\t\tData to be added to the head row; key of the object are the column\n\t*\t\t\t\t\t\t\tnames, values are the column values.DataSeries\n\t* @returns {Promise}\n\t*/\n\tasync set(data) {\n\t\t// Super is not supported on async functions in babel, see \n\t\t// https://github.com/babel/babel/issues/3930\n\t\tDataSeries.prototype.set.call(this, data);\n\t\tawait this.executeAllTransformers();\n\t}\n\n\n\t/**\n\t* Returns true if a given transformer was already executed for the current head row, else false.\n\t* @private\n\t*/\n\twasTransformerExecuted(transformer) {\n\t\treturn this.executedTransformers.indexOf(transformer) > -1;\n\t}\n\n\n\t/**\n\t* Returns an object with all properties if the given properties are available on the head \n\t* data row, else false\n\t* @private\n\t* @param {array} properties\t\tProperties that must exist in order for the function to return\n\t*\t\t\t\t\t\t\t\tan object\n\t* @returns {array|false}\t\tAn array with all the values requested by properties in order \n\t* \t\t\t\t\t\t\t\tof properties.\n\t*/\n\tallPropertiesAvailable(properties) {\n\n\t\tif (!Array.isArray(properties)) {\n\t\t\tthrow new Error(`TransformableDataSeries: Argument passed to allPropertiesAvailable \n\t\t\t\tmust be an array.`);\n\t\t}\n\n\t\tconst headRow = this.head();\n\t\tif (!headRow) {\n\t\t\tthrow new Error(`TransformableDataSeries: Cannot check if all properties are available\n\t\t\t\tas there is no row yet.`);\n\t\t}\n\n\t\t// Any one property is missing: Return false\n\t\tif (!properties.every((property) => headRow.has(property))) return false;\n\n\t\t// Create partial row object and return it\n\t\treturn properties.map((property) => headRow.get(property));\n\n\t}\n\n\n\t/**\n\t* Executes all transformers; when new values become available, starts at the beginning\n\t* @private\n\t*/\n\tasync executeAllTransformers() {\n\n\t\tconst nextExecution = this.getNextTransformerToExecute();\n\t\t// All done\n\t\tif (!nextExecution) return;\n\n\t\tconst { transformer, data } = nextExecution;\n\n\t\t// For params of next(), see addTransformer; DO NOT PASS more data if not absolutely needed\n\t\t// as we want to have stateless/simple transformers\n\t\tconst transformerResult = await transformer.transformer.next(...data);\n\t\tdebug('Executed transformer; result is %o, data was %o', transformerResult, data);\n\t\tthis.executedTransformers.push(transformer.transformer);\n\n\t\tawait this.addTransformedData(transformerResult, transformer);\n\n\t\t// Do the next round and see if other transformers are ready to be executed. We cannot\n\t\t// only call executeAllTransformers on set and add as setting/adding one col might trigger\n\t\t// multiple transformers.\n\t\tawait this.executeAllTransformers();\n\n\t}\n\n\n\t/**\n\t* Gets next transformer to execute on current row or false\n\t* @private\n\t* @returns {object|false} \t\tNext transformer to execute (with properties transformer and \n\t*\t\t\t\t\t\t\t\tdata)and its data, if available, else false.\n\t*/ \n\tgetNextTransformerToExecute() {\n\t\tfor (const transformer of this.transformers) {\n\t\t\t// Transformer has already been executed for this row: Don't do so twice\n\t\t\tif (this.wasTransformerExecuted(transformer.transformer)) continue;\n\t\t\tconst propertiesForTransformer = this.allPropertiesAvailable(transformer.properties);\n\t\t\tif (!propertiesForTransformer) {\n\t\t\t\tdebug('Not all properties available for transformer, continue');\n\t\t\t\tcontinue; // Check next transformer\n\t\t\t}\n\t\t\telse {\n\t\t\t\tconst returnValue = {\n\t\t\t\t\ttransformer: transformer,\n\t\t\t\t\t// Data: values in head row for all properties passed (in the same order)\n\t\t\t\t\tdata: transformer.properties.map((property) => this.head().get(property))\n\t\t\t\t};\n\t\t\t\tdebug(\n\t\t\t\t\t'Execute transformer %o with data %o',\n\t\t\t\t\treturnValue.transformer.constructor.name, \n\t\t\t\t\treturnValue.data,\n\t\t\t\t);\n\t\t\t\treturn returnValue;\n\t\t\t}\n\t\t}\n\t\treturn false;\t\n\t}\n\n\n\t/**\n\t* Adds results of a transformer to latest row. \n\t* @private\n\t* @param {*} result\t\t\t\t\tResult of the transformer to be added; may be an object or\n\t*                       \t\t\tMap (if it contains multiple cols) or anything else (if it's\n\t*                       \t\t\ta single col).\n\t* @param {object} transformer\t\tAn entry of this.transformers\n\t*/\n\tasync addTransformedData(result, transformer) {\n\n\t\t// Data to add to current row\n\t\tconst rowData = new Map();\n\n\t\t// Get columns that are added to DataSeries; when they are created, description is set\n\t\t// if tranformer has a getDescription() method.\n\t\tconst newCols = [];\n\n\t\t// Result is an object (and not a Map): Convert it to a Map for easier handling\n\t\tif (typeof result === 'object' && result !== null && !(result instanceof Map)) {\n\t\t\tconst result = convertObjectToMap(result);\n\t\t}\n\n\t\t// Result is a map: Change key from key passed by transformer to key passed to \n\t\t// addTransformer\n\t\tif (result instanceof Map) {\n\t\t\tfor (const [key, value] of result) {\n\t\t\t\tif (transformer.keys[key] === undefined) {\n\t\t\t\t\tthrow new Error(`TransformableDataSeries: You need to specify a key for every \n\t\t\t\t\t\tresult a transformer returns (as an argument for addTransformer()). \n\t\t\t\t\t\tThe key for ${ key } is missing.`);\n\t\t\t\t}\n\t\t\t\trowData.set(transformer.keys[key], value);\n\t\t\t}\n\t\t}\n\t\t// Result is something else than an object or a Map: Convert it to a map with a single \n\t\t// entry.\n\t\telse {\n\t\t\tif (!transformer.keys) throw new Error(`TransformableDataSeries: Single key missing.`);\n\t\t\trowData.set(transformer.keys, result);\n\t\t}\n\n\t\t// Add keys to columns (if not done yet)\n\t\tfor (const [resultKey] of rowData) {\n\t\t\tif (!this.columns.has(resultKey)) newCols.push(resultKey);\n\t\t}\n\n\t\tdebug('Add transformed data %o to head row', rowData);\n\t\tawait this.set(rowData);\n\n\t\t// Better solution: Use something like setColConfig in DataSeries so that we can config\n\t\t// dataSeries before they're used.\n\t\t//this.updateColumnDefinitions(newCols, transformer.transformer);\n\n\t}\n\n\n\n\t/**\n\t * When a column is newly added, we try to get the column's description text from the \n\t * transformer that was used to create the column value.\n\t * @param {array} columns  \t\t\tColumns that were just created\n\t * @param {object} transformer\t\tTransformer that was used to create the column; may contain\n\t *                              \ta getDescription() property\n\t */\n\t/*updateColumnDefinitions(columns, transformer) {\n\t\tif (typeof transformer.getDescription !== 'function') return;\n\t\tconst description = transformer.getDescription();\n\n\t}*/\n\n\n\t/**\n\t* Takes a value; if it's a promise, returns it, else returns a promised form of value.\n\t*\n\t* @private\n\t* @param {*} value\n\t* @returns {Promise}\n\t*/\n\t/*createPromiseFromTransformer(value) {\n\t\tif (value && value instanceof Promise) return value;\n\t\t// Return a synchronously resolving promise\n\t\t// (and not async by creating a new promise and then in the next loop resolving it)\n\t\treturn Promise.resolve(value);\n\t}*/\n\n\n\t/**\n\t* Adds a transformer. A transformer is an object (or instantiated class) that must contain a \n\t* method called next. The next method is called whenever all properties specified are available \n\t* for any given row.\n\t* The next method must return an object or a value which will be merged with the new row.\n\t* @param {array} properties\t\tProperties to watch; when all properties are available, \n\t*\t\t\t\t\t\t\t\tthe transformer's next() method will be called. If the array is\n\t*\t\t\t\t\t\t\t\tempty, transformer.next() will be called before any value is \n\t*\t\t\t\t\t\t\t\tadded to the data series (therefore with an empty data series). \n\t*\t\t\t\t\t\t\t\tThis is amongst others needed to clone previous values (e.g.\n\t*\t\t\t\t\t\t\t\tpositions – is it?).\n\t* @param {object} transformer\tTransformer; is an object/instantiated class with a method \n\t*\t\t\t\t\t\t\t\tcalled next(). next() will be called whenever all properties are \n\t*\t\t\t\t\t\t\t\tavailable. Must return either a single value or a Map() that \n\t*\t\t\t\t\t\t\t\twill be merged with the current row. \n\t*\t\t\t\t\t\t\t\tThe transformer's next() method will be called with the \n\t*\t\t\t\t\t\t\t\tfollowing parameters: \n\t*\t\t\t\t\t\t\t\t- array of values for the head() row of all properties (see \n\t*\t\t\t\t\t\t\t\t  above).\n\t*\t\t\t\t\t\t\t\tWe use no further parameters (e.g. the whole head row or the\n\t*\t\t\t\t\t\t\t\twhole data set) to keep our transformers clean. \n\t* @param {object|*} keys\t\tKeys that we use to store the transformer's return values in \n\t*                         \t\tthis DataSeries. If tranformer returns a single value, pass \n\t*                         \t\tanything that can be used as a key in a Map(). If transformer \n\t*                         \t\treturns multiple values (as an object), pass an object; keys\n\t*                         \t\tare the keys of the object returned by the transformer, values\n\t*                         \t\tthe keys used to store the value in this DataSeries. Try to use\n\t*                         \t\tSymbols() as the whole idea of using keys is to prevent clashes\n\t*                         \t\tof keys. \n\t*                         \t\t(In an earlier version, we created Symbols() as keys and \n\t*                         \t\treturned the mapping. This made things too complicated (in Algos\n\t*                         \t\twhere we had to store multiple keys for multiple instruments). \n\t* @returns {object}\t\t\t\tAn object with keys and their corresponding symbols that will\n\t* \t\t\t\t\t\t\t\tbe used to attach the transformer's result to the row. If a \n\t*\t\t\t\t\t\t\t\ttransformer's next method returns { top: 5, bottom: 2}, it must\n\t* \t\t\t\t\t\t\t\timplement a method getKeys that returns ['top', 'bottom']. Those\n\t*\t\t\t\t\t\t\t\twill be transformed to Symbols in the row and this function will\n\t*\t\t\t\t\t\t\t\treturn { topKey: Symbol(), bottomKey: Symbol() } where both \n\t*\t\t\t\t\t\t\t\tSymbols are used to access the transformer's result. Using\n\t*\t\t\t\t\t\t\t\tsymbols internally (instead of a passed-in name) allows us to\n\t*\t\t\t\t\t\t\t\tprevent any key collisions.\n\t*/\n\taddTransformer(properties, transformer, keys) {\n\n\t\tif (!Array.isArray(properties)) {\n\t\t\tthrow new Error(`TransformableDataSeries: Argument 'properties' for addTransformer \n\t\t\t\tmust be an array, is ${ typeof properties }.`);\n\t\t}\n\n\t\tif (!transformer || typeof transformer !== 'object') {\n\t\t\tthrow new Error(`TransformableDataSeries: The transformer you added through \n\t\t\t\taddTransformer must be an object, is of type ${ typeof transformer }.`);\n\t\t}\n\n\t\tif (!transformer.next || typeof transformer.next !== 'function') {\n\t\t\tthrow new Error(`TransformableDataSeries: Every transformer must have a next method.`);\n\t\t}\n\n\t\tthis.transformers.push({\n\t\t\tproperties: properties,\n\t\t\ttransformer: transformer,\n\t\t\tkeys: keys,\n\t\t});\n\n\t\tdebug('Add transformer %o with properties %o and keys %o', transformer, properties, keys);\n\n\t}\n\n}\n\n"],"file":"TransformableDataSeries.mjs"}